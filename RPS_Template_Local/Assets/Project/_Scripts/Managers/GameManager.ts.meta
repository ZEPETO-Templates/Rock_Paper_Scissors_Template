fileFormatVersion: 2
guid: 973fbf2751fb4654cb5d2f8acdb422a6
importerOverride: ZEPETO.Script.Compiler:ZEPETO.Script:TypescriptAssetImporter
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: -1123457745, guid: 54cf806323ffe4418a4ce4cc63fe6b9d, type: 3}
  isAssemblyDeclarations: 0
  assembly: 
  generateAllTypes: 1
  types: []
  generateWrapper: 0
  overrideWrapperTypes: 0
  wrapperTypes: []
  WrapperFilters: []
  wrapperOutputDirectory: Generated
  compiledResult: '{"source":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\",
    { value: true });\r\nconst UnityEngine_1 = require(\"UnityEngine\");\r\nconst
    ZEPETO_Script_1 = require(\"ZEPETO.Script\");\r\nconst UIManager_1 = require(\"./UIManager\");\r\n//
    This class is responsible for handling everything related to the gameplay of
    the game, calling other managers if necessary.\r\nclass GameManager extends ZEPETO_Script_1.ZepetoScriptBehaviour
    {\r\n    // Awake is called when an enabled script instance is being loaded.\r\n   
    Awake() {\r\n        // Singleton pattern\r\n        if (ZEPETO_Script_1.ZepetoScriptBehaviour.op_Inequality(GameManager.instance,
    null))\r\n            UnityEngine_1.GameObject.Destroy(this.gameObject);\r\n       
    else\r\n            GameManager.instance = this;\r\n    }\r\n    // This functions
    will set the selection of the player hand\r\n    SelectPlayerHand(selection)
    {\r\n        // Call to the function SelectPlayerSprite on the UIManager\r\n       
    UIManager_1.default.instance.SelectPlayerSprite(selection);\r\n        // Set
    the player selection\r\n        this.playerSelection = selection;\r\n    }\r\n   
    // This function will select the opponent hand (rock, paper or scissors)\r\n   
    SelectOpponentHand() {\r\n        // first we will let the variables to get a
    random hand\r\n        // Setting the random selection\r\n        let rnd = 0;\r\n       
    // Set the limit on the sprite amount on the UIManager\r\n        let limit =
    3;\r\n        // Select a random number between 0 and the limit\r\n        rnd
    = UnityEngine_1.Random.Range(0, limit);\r\n        // if rnd gets a float as
    result it gets rounded to int\r\n        rnd = UnityEngine_1.Mathf.FloorToInt(rnd);\r\n       
    // console.log( \"Rnd: \" + rnd );\r\n        // Call to the function SelectOpponentSprite
    on the UIManager\r\n        UIManager_1.default.instance.SelectOpponentSprite(rnd);\r\n       
    // Set the opponent selection to the random selection\r\n        this.opponentSelection
    = rnd;\r\n        this.Match();\r\n    }\r\n    // This function is responsible
    for comparing the hands selected by the player and the CPU, determining who will
    be the winner.\r\n    Match() {\r\n        // console.log( \"Player: \" + this.playerSelection
    + \" // Opponent: \" + this.opponentSelection );\r\n        // We check if both
    selected the same thing.\r\n        if (this.playerSelection == this.opponentSelection)
    {\r\n            // We start the coroutine to resolve the situation.\r\n           
    this.StartCoroutine(this.WaitToResolve(false, true));\r\n            // Then
    stop the function\r\n            return;\r\n        }\r\n        // Set the variable
    to know if the player wins, letting this on false we only need to check if the
    player wins and not if he loses\r\n        let playerWins = false;\r\n       
    // We create a switch to cover the different possible selections of the player.\r\n       
    switch (this.playerSelection) {\r\n            // In the case that the player
    has selected \"rock\"...\r\n            case 0:\r\n                // We check
    if the opponent selected \"scissors\" and set the playerWins\r\n               
    if (this.opponentSelection == 2) {\r\n                    playerWins = true;\r\n               
    }\r\n                break;\r\n            // In the case that the player has
    selected \"rock\"...\r\n            case 1:\r\n                // We check if
    the opponent selected \"scissors\" and set the playerWins\r\n               
    if (this.opponentSelection == 0) {\r\n                    playerWins = true;\r\n               
    }\r\n                break;\r\n            // In the case that the player has
    selected \"scissors\"...\r\n            case 2:\r\n                // We check
    if the opponent selected \"paper\" and set the playerWins\r\n               
    if (this.opponentSelection == 1) {\r\n                    playerWins = true;\r\n               
    }\r\n                break;\r\n        }\r\n        // We start the coroutine
    to resolve the situation. \r\n        this.StartCoroutine(this.WaitToResolve(playerWins));\r\n   
    }\r\n    // This function is a Coroutine that shows the counter before start
    the game\r\n    *WaitToStart() {\r\n        // Set a counter with the variable
    previously assigned by inspector with the time to start\r\n        let counter
    = this.counterToStart;\r\n        // Call the function of the UIManager to show
    the number on the text\r\n        UIManager_1.default.instance.counterText.text
    = counter.toString();\r\n        // Deactivate the play button of the UI using
    the variable of the UIManager\r\n        UIManager_1.default.instance.playBtn.gameObject.SetActive(false);\r\n       
    // Activate the object of the counter in the UI using the variable of the UIManager\r\n       
    UIManager_1.default.instance.counterObj.SetActive(true);\r\n        // Here we
    start a loop to count by seconds and show that on the counter object\r\n       
    while (true) {\r\n            // Here we wait 1 second before continue with the
    code\r\n            yield new UnityEngine_1.WaitForSeconds(1);\r\n           
    // We subtract 1 from the counter variable\r\n            counter--;\r\n           
    // Update the counter text in the UI using the variable of the UIManager\r\n           
    UIManager_1.default.instance.counterText.text = counter.toString();\r\n           
    // console.log( \"Counter: \" + counter );\r\n            // We chekc if the
    counter is 0 then we break the loop to continue with the code\r\n           
    if (counter == 0)\r\n                break;\r\n        }\r\n        // Update
    the counter text to \"START!\" in the UI using the variable of the UIManager\r\n       
    UIManager_1.default.instance.counterText.text = \"START!\";\r\n        // Wait
    for 0.5 seconds to continue, giving sometime to see the \"Start!\" text\r\n       
    yield new UnityEngine_1.WaitForSeconds(0.5);\r\n        // Then we need to restart
    the panles, so we use the instance of the UIManager to:\r\n        // Deactivate
    the counter object\r\n        UIManager_1.default.instance.counterObj.SetActive(false);\r\n       
    // Activate the play button\r\n        UIManager_1.default.instance.playBtn.gameObject.SetActive(true);\r\n       
    // Deactivate the startPanel \r\n        UIManager_1.default.instance.startPanel.SetActive(false);\r\n       
    // Activate the gamePanel\r\n        UIManager_1.default.instance.gamePanel.SetActive(true);\r\n       
    // With this, now we are showing the game panel to start play\r\n        // and
    we reset the start panel if the player wants to play again\r\n    }\r\n    //
    This function is a coroutine that handles resolving the winner, resetting the
    selections, and passing some time to the winner later on\r\n    *WaitToResolve(playerWins,
    draw = false) {\r\n        // Here we wait 1 second before continue with the
    code\r\n        yield new UnityEngine_1.WaitForSeconds(1);\r\n        // We check
    if there was a tie based on the obtained parameters.\r\n        if (draw) {\r\n           
    // Call to the CleanSelections function of the UIManager instance\r\n           
    UIManager_1.default.instance.CleanSelections();\r\n            // Call to the
    ShowDrawEndPanel function of the UIManager instance\r\n            UIManager_1.default.instance.ShowDrawEndPanel();\r\n           
    // Stop the execution of the function.\r\n            return;\r\n        }\r\n       
    // Call to the CleanSelections function of the UIManager instance\r\n       
    UIManager_1.default.instance.CleanSelections();\r\n        // We check if the
    player won. If so, we call the \"ShowEndPanel\" function from the UIManager instance.\r\n       
    // Passing as parameters the text to be displayed for the winner and a boolean
    that determines if the player won or not.\r\n        // If not, we will call
    the same function but specifying that the winner was the CPU.\r\n        if (playerWins)\r\n           
    UIManager_1.default.instance.ShowEndPanel(\"Player\", true);\r\n        else\r\n           
    UIManager_1.default.instance.ShowEndPanel(\"CPU\", false);\r\n    }\r\n}\r\nexports.default
    = GameManager;\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FtZU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJHYW1lTWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZDQUF3RTtBQUN4RSxpREFBcUQ7QUFDckQsMkNBQW9DO0FBRXBDLDhIQUE4SDtBQUM5SCxNQUFxQixXQUFZLFNBQVEscUNBQXFCO0lBUTFELG1FQUFtRTtJQUNuRSxLQUFLO1FBQ0Qsb0JBQW9CO1FBQ3BCLElBZkMscUNBQXFCLENBcUtqQixhQUFjLENBdEpkLFdBQVcsQ0FBQyxRQUFRLEVBQUksSUFBSTtZQUFHLHdCQUFVLENBQUMsT0FBTyxDQUFFLElBQUksQ0FBQyxVQUFVLENBQUUsQ0FBQzs7WUFDckUsV0FBVyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7SUFDckMsQ0FBQztJQUVELDJEQUEyRDtJQUNwRCxnQkFBZ0IsQ0FBRyxTQUFjO1FBQ3BDLDJEQUEyRDtRQUMzRCxtQkFBUyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBRSxTQUFTLENBQUUsQ0FBQztRQUVuRCwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxTQUFTLENBQUM7SUFFckMsQ0FBQztJQUVELHdFQUF3RTtJQUNqRSxrQkFBa0I7UUFDckIsdURBQXVEO1FBRXZELCtCQUErQjtRQUMvQixJQUFJLEdBQUcsR0FBUSxDQUFDLENBQUM7UUFFakIsc0RBQXNEO1FBQ3RELElBQUksS0FBSyxHQUFRLENBQUMsQ0FBQztRQUVuQixpREFBaUQ7UUFDakQsR0FBRyxHQUFHLG9CQUFNLENBQUMsS0FBSyxDQUFFLENBQUMsRUFBRSxLQUFLLENBQUUsQ0FBQztRQUUvQix1REFBdUQ7UUFDdkQsR0FBRyxHQUFHLG1CQUFLLENBQUMsVUFBVSxDQUFFLEdBQUcsQ0FBRSxDQUFDO1FBRTlCLGdDQUFnQztRQUVoQyw2REFBNkQ7UUFDN0QsbUJBQVMsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUUsR0FBRyxDQUFFLENBQUM7UUFFL0MscURB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","assetPath":"Assets/Project/_Scripts/Managers/GameManager.ts","manifest":{"properties":[{"assembly":"mscorlib","name":"counterToStart","type":"System.Single","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"SerializeField","args":[]}]}],"name":"GameManager","description":"","hasAnimatorMove":false},"isCompiled":true}'
  typescriptHash: 1b5f867ec29111ac99c741186f5c3a7c
  onlyWriteTrigger: 0
